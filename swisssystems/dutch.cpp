#include <algorithm>
#include <cassert>
#include <cstdint>
#include <deque>
#include <iterator>
#include <list>
#include <ostream>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

#include <tournament/tournament.h>
#include <utility/typesizes.h>
#include <utility/uintstringconversion.h>
#include <utility/uinttypes.h>

#include "common.h"
#include "dutch.h"

#ifndef OMIT_DUTCH
namespace swisssystems
{
  namespace dutch
  {
    namespace
    {
      /**
       * Determine whether the two players could meet without violating absolute
       * criteria.
       */
      bool compatible(
        const tournament::Player &player0,
        const tournament::Player &player1,
        const tournament::Tournament &tournament)
      {
        constexpr unsigned int maxPointsSize =
          utility::typesizes
              ::bitsToRepresent<unsigned int>(tournament::maxRounds)
            + utility::typesizes
                ::bitsToRepresent<unsigned int>(tournament::maxPoints);
        static_assert(
          maxPointsSize
            >= utility::typesizes
                 ::bitsToRepresent<unsigned int>(tournament::maxRounds),
          "Overflow");

        const auto topScoreThreshold =
          utility::uinttypes
              ::uint_least<maxPointsSize>{ tournament.playedRounds }
            * std::max(tournament.pointsForWin, tournament.pointsForDraw)
            >> 1;
        return
          !player0.forbiddenPairs.count(player1.id)
            && (!player0.absoluteColorPreference()
                  || !player1.absoluteColorPreference()
                  || player0.colorPreference != player1.colorPreference
                  || (tournament.playedRounds >= tournament.expectedRounds - 1u
                        && (player0.scoreWithAcceleration(tournament)
                                > topScoreThreshold
                              || player1.scoreWithAcceleration(tournament)
                                  > topScoreThreshold)
                      )
                );
      }

      /**
       * Check whether the matching last generated by matchingComputer
       * is an eligible round pairing (where at least all players but one are
       * matched and no absolute criteria are violated).
       */
      bool
        matchingIsComplete(const validity_matching_computer &matchingComputer)
      {
        tournament::player_index vertexIndex{ };
        for (
          const tournament::player_index matchedIndex
            : matchingComputer.getMatching())
        {
          if (matchedIndex == vertexIndex++)
          {
            return false;
          }
        }
        return true;
      }

      /**
       * The different types of floaters.
       */
      enum Float : utility::uinttypes::uint_least_for_value<3>
      {
        FLOAT_DOWN, FLOAT_UP, FLOAT_NONE
      };

      /**
       * Determine the float direction of the specified player on the round that
       * is roundsBack before the current round.
       */
      Float getFloat(
        const tournament::Player &player,
        const tournament::round_index roundsBack,
        const tournament::Tournament &tournament)
      {
        const tournament::Match &match =
          player.matches[tournament.playedRounds - roundsBack];
        if (!match.gameWasPlayed)
        {
          return FLOAT_DOWN;
        }
        const tournament::points playerScore =
          player.scoreWithAcceleration(tournament, roundsBack);
        const tournament::points opponentScore =
          tournament.players[match.opponent]
            .scoreWithAcceleration(tournament, roundsBack);
        return
          playerScore > opponentScore ? FLOAT_DOWN
            : playerScore < opponentScore ? FLOAT_UP
            : FLOAT_NONE;
      }

      /**
       * Left-shift the edgeWeight by the specified amount. If max is true,
       * also expand the number of pieces in edgeWeight so the shifted value
       * will fit.
       */
      template <bool max, typename Shift>
      void shiftEdgeWeight(
        optimality_matching_computer::edge_weight &edgeWeight,
        const Shift shift)
      {
        if (max)
        {
          edgeWeight.shiftGrow(shift);
        }
        else
        {
          edgeWeight <<= shift;
        }
      }

      /**
       * Given edgeWeight containing the high-order bits of the edge weight,
       * shift it over to make room for the bits reserved for color preferences,
       * and set the appropriate bits to true.
       * If max is true, just shift without setting bits to true.
       */
      template <bool max>
      void insertColorBits(
        optimality_matching_computer::edge_weight &edgeWeight,
        const tournament::Player &player,
        const tournament::Player &opponent,
        const bool inCurrentScoreGroup,
        const tournament::player_index playerCountBits)
      {
        const bool mask = !max && inCurrentScoreGroup;

        shiftEdgeWeight<max>(edgeWeight, playerCountBits);
        edgeWeight |=
          mask
            && (!player.absoluteColorImbalance()
                  || !opponent.absoluteColorImbalance()
                  || player.colorPreference != opponent.colorPreference);

        shiftEdgeWeight<max>(edgeWeight, playerCountBits);
        edgeWeight |=
          mask
            && (!player.absoluteColorPreference()
                  || !opponent.absoluteColorPreference()
                  || player.colorPreference != opponent.colorPreference
                  || (player.colorImbalance == opponent.colorImbalance
                        ? player.repeatedColor == tournament::COLOR_NONE
                            || player.repeatedColor != opponent.repeatedColor
                        : (player.colorImbalance > opponent.colorImbalance
                            ? opponent
                            : player
                          ).repeatedColor
                              != tournament::invert(player.colorPreference)));

        shiftEdgeWeight<max>(edgeWeight, playerCountBits);
        edgeWeight |=
          mask
            && colorPreferencesAreCompatible(
                player.colorPreference,
                opponent.colorPreference);

        shiftEdgeWeight<max>(edgeWeight, playerCountBits);
        edgeWeight |=
          mask
            && ((!player.strongColorPreference
                    && !player.absoluteColorPreference()
                  ) || (!opponent.strongColorPreference
                          && !opponent.absoluteColorPreference())
                    || (player.absoluteColorPreference()
                          && opponent.absoluteColorPreference())
                    || player.colorPreference != opponent.colorPreference
                );
      }

      typedef
        utility::uinttypes::uint_least_for_value<
          std::uintmax_t{ tournament::maxPoints } + 10u>
        score_difference;
      static_assert(
        std::uintmax_t{ tournament::maxPoints } + 10u >= 10u,
        "Overflow");

      constexpr unsigned int scoreDifferenceShiftSize =
        utility::typesizes
            ::bitsToRepresent<unsigned int>(tournament::maxPlayers)
          * 2u;
      typedef
        utility::uinttypes::uint_least<scoreDifferenceShiftSize>
        score_difference_shift;
      static_assert(
        scoreDifferenceShiftSize >> 1
          >= utility::typesizes
              ::bitsToRepresent<unsigned int>(tournament::maxPlayers),
        "Overflow");

      /**
       * Compute the basic edge weight between the two players. If max is true,
       * compute an upper bound on the edge weight for this pairing bracket
       * instead.
       */
      template <bool max = false>
      optimality_matching_computer::edge_weight
        computeEdgeWeight(
          const tournament::Player &higherPlayer,
          const tournament::Player &lowerPlayer,
          const bool specialBrackets,
          const bool finalBrackets,
          const bool higherPlayerInCurrentBracket,
          const bool lowerPlayerInCurrentBracket,
          const tournament::Tournament &tournament,
          const unsigned int playerCountBits,
          const unsigned int nextScoreGroupPlayerCountBits,
          const score_difference_shift scoreDifferenceShift,
          const std::unordered_map<score_difference, score_difference_shift>
            &scoreDifferenceShifts,
          const tournament::points minScoreInBracket,
          optimality_matching_computer::edge_weight &maxEdgeWeight)
      {
        typename
            std::conditional<
              max,
              decltype(maxEdgeWeight),
              optimality_matching_computer::edge_weight
            >::type
          result{ maxEdgeWeight };

        result &= 0u;

        // Check compatibility.
        if (!max && !compatible(higherPlayer, lowerPlayer, tournament))
        {
          return result;
        }

        // Enforce completion requirement and bye eligibility.
        if (specialBrackets)
        {
          result |=
            max
              ? 2u
              : 1u
                  + !eligibleForBye(higherPlayer, tournament)
                  + !eligibleForBye(lowerPlayer, tournament);
        }

        // Maximize the number of pairs in the current pairing bracket.
        assert(playerCountBits);
        shiftEdgeWeight<max>(result, playerCountBits);
        result |= max ? !result : lowerPlayerInCurrentBracket;

        // Minimize the pairing score difference in the current bracket.
        shiftEdgeWeight<max>(result, scoreDifferenceShift);
        if (!max && lowerPlayerInCurrentBracket)
        {
          result +=
            ((result & 0u) | 1u)
              << scoreDifferenceShifts.find(
                    score_difference(
                      higherPlayer.scoreWithAcceleration(tournament)
                        - minScoreInBracket
                    ) + 10u
                  )->second;
          result +=
            ((result & 0u) | 1u)
              << scoreDifferenceShifts.find(
                    score_difference(
                      lowerPlayer.scoreWithAcceleration(tournament)
                        - minScoreInBracket
                    ) + 10u
                  )->second;
          result -=
            ((result & 0u) | 1u)
              << scoreDifferenceShifts.find(
                  higherPlayer.scoreWithAcceleration(tournament)
                    - lowerPlayer.scoreWithAcceleration(tournament))->second;
        }

        if (!specialBrackets)
        {
          assert(nextScoreGroupPlayerCountBits);

          // Maximize the number of pairs in the next bracket.
          if (finalBrackets)
          {
            shiftEdgeWeight<max>(
              result,
              std::max(playerCountBits, nextScoreGroupPlayerCountBits));
            shiftEdgeWeight<max>(result, 3u);
          }
          else
          {
            shiftEdgeWeight<max>(result, nextScoreGroupPlayerCountBits);
          }
          result |=
            max ? 0u
              : finalBrackets
                ? 1u
                    + !eligibleForBye(higherPlayer, tournament)
                    + !eligibleForBye(lowerPlayer, tournament)
              : !lowerPlayerInCurrentBracket;

          // Maximize the pair scoring difference in the next bracket.
          shiftEdgeWeight<max>(result, scoreDifferenceShift);
          if (!max)
          {
            if (higherPlayerInCurrentBracket)
            {
              result |=
                ((result & 0u) | 1u)
                  << scoreDifferenceShifts.find(
                        score_difference(
                          higherPlayer.scoreWithAcceleration(tournament)
                            - minScoreInBracket
                        ) + 10u
                      )->second;
            }
            if (lowerPlayerInCurrentBracket)
            {
              result +=
                ((result & 0u) | 1u)
                  << scoreDifferenceShifts.find(
                        score_difference(
                          lowerPlayer.scoreWithAcceleration(tournament)
                            - minScoreInBracket
                        ) + 10u
                      )->second;
            }
          }
        }

        // Maximize color preference satisfaction.
        insertColorBits<max>(
          result,
          lowerPlayer,
          higherPlayer,
          lowerPlayerInCurrentBracket,
          playerCountBits);

        if (tournament.playedRounds)
        {
          // Minimize downfloaters repeated from the previous round.
          shiftEdgeWeight<max>(result, playerCountBits);
          if (!max && lowerPlayerInCurrentBracket)
          {
            result |= getFloat(lowerPlayer, 1, tournament) == FLOAT_DOWN;
            result +=
              higherPlayer.scoreWithAcceleration(tournament)
                  <= lowerPlayer.scoreWithAcceleration(tournament)
                && getFloat(higherPlayer, 1, tournament) == FLOAT_DOWN;
          }

          // Minimize upfloaters repeated from the previous round.
          shiftEdgeWeight<max>(result, playerCountBits);
          result -=
            !max
              && lowerPlayerInCurrentBracket
              && higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament)
              && getFloat(lowerPlayer, 1, tournament) == FLOAT_UP;
        }
        if (tournament.playedRounds > 1u)
        {
          // Minimize downfloaters repeated from two rounds before.
          shiftEdgeWeight<max>(result, playerCountBits);
          if (!max && lowerPlayerInCurrentBracket)
          {
            result |= getFloat(lowerPlayer, 2, tournament) == FLOAT_DOWN;
            result +=
              higherPlayer.scoreWithAcceleration(tournament)
                  <= lowerPlayer.scoreWithAcceleration(tournament)
                && getFloat(higherPlayer, 2, tournament) == FLOAT_DOWN;
          }

          // Minimize upfloaters repeated from two rounds before.
          shiftEdgeWeight<max>(result, playerCountBits);
          result -=
            !max
              && lowerPlayerInCurrentBracket
              && higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament)
              && getFloat(lowerPlayer, 2, tournament) == FLOAT_UP;
        }

        if (tournament.playedRounds)
        {
          // Minimize the score differences of downfloaters repeated from the
          // previous round.
          shiftEdgeWeight<max>(result, scoreDifferenceShift);
          if (!max && lowerPlayerInCurrentBracket)
          {
            result +=
              ((result & 0u)
                | (getFloat(lowerPlayer, 1, tournament) == FLOAT_DOWN)
              ) << scoreDifferenceShifts.find(
                      score_difference(
                        lowerPlayer.scoreWithAcceleration(tournament)
                          - minScoreInBracket
                      ) + 10u
                    )->second;
            if (getFloat(higherPlayer, 1, tournament) == FLOAT_DOWN)
            {
              result +=
                ((result & 0u) | 1u)
                  << scoreDifferenceShifts.find(
                        score_difference(
                          higherPlayer.scoreWithAcceleration(tournament)
                            - minScoreInBracket
                        ) + 10u
                      )->second;
              if (
                higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament))
              {
                result -=
                  ((result & 0u) | 1u)
                    << scoreDifferenceShifts.find(
                          higherPlayer.scoreWithAcceleration(tournament)
                            - lowerPlayer.scoreWithAcceleration(tournament)
                        )->second;
              }
            }
          }

          // Minimize the score differences of upfloaters repeated from the
          // previous round.
          shiftEdgeWeight<max>(result, scoreDifferenceShift);
          if (
            !max
              && lowerPlayerInCurrentBracket
              && getFloat(lowerPlayer, 1, tournament) == FLOAT_UP
              && higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament))
          {
            result -=
              ((result & 0u) | 1u)
                << scoreDifferenceShifts.find(
                      higherPlayer.scoreWithAcceleration(tournament)
                        - lowerPlayer.scoreWithAcceleration(tournament)
                    )->second;
          }
        }
        if (tournament.playedRounds > 1u)
        {
          // Minimize the score differences of downfloaters repeated from two
          // rounds before.
          shiftEdgeWeight<max>(result, scoreDifferenceShift);
          if (!max && lowerPlayerInCurrentBracket)
          {
            result +=
              ((result & 0u)
                | (getFloat(lowerPlayer, 2, tournament) == FLOAT_DOWN)
              ) << scoreDifferenceShifts.find(
                      score_difference(
                        lowerPlayer.scoreWithAcceleration(tournament)
                          - minScoreInBracket
                      ) + 10u
                    )->second;
            if (getFloat(higherPlayer, 2, tournament) == FLOAT_DOWN)
            {
              result +=
                ((result & 0u) | 1u)
                  << scoreDifferenceShifts.find(
                        score_difference(
                          higherPlayer.scoreWithAcceleration(tournament)
                            - minScoreInBracket
                        ) + 10u
                      )->second;
              if (
                higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament))
              {
                result -=
                  ((result & 0u) | 1u)
                    << scoreDifferenceShifts.find(
                          higherPlayer.scoreWithAcceleration(tournament)
                            - lowerPlayer.scoreWithAcceleration(tournament)
                        )->second;
              }
            }
          }

          // Minimize the score differences of upfloaters repeated from two
          // rounds before.
          shiftEdgeWeight<max>(result, scoreDifferenceShift);
          if (
            !max
              && lowerPlayerInCurrentBracket
              && getFloat(lowerPlayer, 2, tournament) == FLOAT_UP
              && higherPlayer.scoreWithAcceleration(tournament)
                  > lowerPlayer.scoreWithAcceleration(tournament))
          {
            result -=
              ((result & 0u) | 1u)
                << scoreDifferenceShifts.find(
                      higherPlayer.scoreWithAcceleration(tournament)
                        - lowerPlayer.scoreWithAcceleration(tournament)
                    )->second;
          }
        }

        // Leave room for enforcing the ordering requirements for pairing
        // heterogeneous and homogeneous brackets.
        shiftEdgeWeight<max>(result, playerCountBits);

        shiftEdgeWeight<max>(result, playerCountBits);
        shiftEdgeWeight<max>(result, playerCountBits);

        shiftEdgeWeight<max>(result, 1u);

        if (max)
        {
          // The edge weight should have room to expand by two bits for the
          // matching subroutine.
          // Subtracting 1 sets all bits to 1.
          result.shiftGrow(2u);
          result >>= 1u;
          result -= 1u;
        }

        return result;
      }

      /**
       * A function to compute the piece color given to the first argument,
       * whose opponent is the second argument.
       */
      tournament::Color choosePlayerColor(
        const tournament::Player &player,
        const tournament::Player &opponent,
        const tournament::Tournament &tournament)
      {
        const tournament::Color result =
          choosePlayerNeutralColor(player, opponent);
        return
          result == tournament::COLOR_NONE
            ? player.colorPreference == tournament::COLOR_NONE
                ? tournament::acceleratedScoreRankCompare(
                      &player,
                      &opponent,
                      tournament)
                    ? opponent.rankIndex & 1u
                        ? tournament.initialColor
                        : invert(tournament.initialColor)
                    : player.rankIndex & 1u
                        ? invert(tournament.initialColor)
                        : tournament.initialColor
                : tournament::acceleratedScoreRankCompare(
                      &player,
                      &opponent,
                      tournament)
                    ? invert(opponent.colorPreference)
                    : player.colorPreference
            : result;

      }

      /**
       * Return a character used in the checklist file to represent the
       * specified float direction.
       */
      char floatToChar(const Float floatDirection)
      {
        return
          floatDirection == FLOAT_DOWN ? 'D'
            : floatDirection == FLOAT_UP ? 'U'
            : ' ';
      }

      /**
       * Print the checklist file for the current round to ostream.
       */
      void printChecklist(
        const tournament::Tournament &tournament,
        const std::list<const tournament::Player *> &sortedPlayers,
        std::ostream &ostream,
        const std::vector<const tournament::Player *> *const matching = nullptr)
      {
        swisssystems::printChecklist(
          ostream,
          std::deque<std::string>{"C2", "C12", "C14", "Cur"},
          [&matching, &tournament]
            (const tournament::Player &player)
          {
            const tournament::Player *opponent =
              matching ? (*matching)[player.id] : nullptr;
            return std::deque<std::string>{
              eligibleForBye(player, tournament) ? "Y" : "N",
              std::string{
                floatToChar(
                  tournament.playedRounds
                    ? getFloat(player, 1, tournament)
                    : FLOAT_NONE)
              },
              std::string{
                floatToChar(
                  tournament.playedRounds > 1u
                    ? getFloat(player, 2, tournament)
                    : FLOAT_NONE)
              },
              matching
                ? opponent
                    ? '('
                        + utility::uintstringconversion
                            ::toString(opponent->id + 1u)
                        + (choosePlayerColor(player, *opponent, tournament)
                            == tournament::COLOR_WHITE ? 'W' : 'B'
                          )
                        + ')'
                    : "(bye)"
                : ""
            };
          },
          tournament,
          sortedPlayers
        );
      }

      /**
       * Compute the basic edge weights for all possible pairings in this
       * pairing bracket and the next. The resulting vector is indexed by the
       * larger player index, and the sub-vectors are indexed by the smaller
       * player index.
       */
      std::vector<std::vector<optimality_matching_computer::edge_weight>>
      computeBaseEdgeWeights(
        optimality_matching_computer::edge_weight &maxEdgeWeight,
        const std::vector<const tournament::Player *> &playersByIndex,
        const tournament::player_index scoreGroupBegin,
        const tournament::player_index nextScoreGroupBegin,
        const bool specialBrackets,
        const bool finalBrackets,
        const tournament::Tournament &tournament)
      {
        // Get an upper bound on the number of occurences of each score
        // difference in the current pairing bracket.
        const tournament::points minScoreInBracket =
          playersByIndex.back()->scoreWithAcceleration(tournament);
        std::list<score_difference> scoreDifferences;
        for (
          tournament::player_index playerIndex = 0;
          playerIndex < nextScoreGroupBegin;
          ++playerIndex)
        {
          // Include score differences for downfloaters.
          scoreDifferences.push_back(
            score_difference(
              playersByIndex[playerIndex]->scoreWithAcceleration(tournament)
                - minScoreInBracket
            ) + 10u
          );
          const tournament::player_index firstIndex =
            std::max<tournament::player_index>(scoreGroupBegin, playerIndex + 1u
            );
          // Add score differences for non-downfloaters.
          for (
            tournament::player_index opponentIndex = firstIndex;
            opponentIndex < nextScoreGroupBegin;
            ++opponentIndex)
          {
            // Repeated score differences for a single player need only be
            // counted once.
            if (
              opponentIndex <= firstIndex
                || playersByIndex[opponentIndex]
                      ->scoreWithAcceleration(tournament)
                    < playersByIndex[opponentIndex - 1u]
                        ->scoreWithAcceleration(tournament))
            {
              scoreDifferences.push_back(
                score_difference(
                  playersByIndex[playerIndex]->scoreWithAcceleration(tournament)
                    - playersByIndex[opponentIndex]
                        ->scoreWithAcceleration(tournament)));
            }
          }
        }
        scoreDifferences.sort();

        // Determine the number of bits needed for each score difference.
        score_difference_shift scoreDifferenceShift{ };
        std::unordered_map<score_difference, score_difference_shift>
          scoreDifferenceShifts;
        tournament::player_index repeatedScores{ };
        for (
          decltype(scoreDifferences)::const_iterator nextIterator =
            scoreDifferences.begin();
          nextIterator != scoreDifferences.end();
        )
        {
          const decltype(scoreDifferences)::const_iterator currentIterator =
            nextIterator++;
          ++repeatedScores;
          if (
            nextIterator == scoreDifferences.end()
              || *currentIterator != *nextIterator)
          {
            const unsigned int newBits =
              utility::typesizes::bitsToRepresent<unsigned int>(repeatedScores);
            scoreDifferenceShifts[*currentIterator] = scoreDifferenceShift;
            repeatedScores = 0;
            scoreDifferenceShift += newBits;
            assert(scoreDifferenceShift >= newBits);
          }
        }

        // Determine the number of bits needed to represent the players in this
        // score group and the next, respectively.
        assert(scoreGroupBegin < nextScoreGroupBegin);
        const unsigned int playerCountBits =
          utility::typesizes::bitsToRepresent<unsigned int>(
            nextScoreGroupBegin - scoreGroupBegin);
        const unsigned int nextScoreGroupPlayerCountBits =
          utility::typesizes::bitsToRepresent<unsigned int>(
            playersByIndex.size() - nextScoreGroupBegin);

        // Compute an edge weight upper bound.
        computeEdgeWeight<true>(
          *playersByIndex[0],
          *playersByIndex[0],
          specialBrackets,
          finalBrackets,
          true,
          true,
          tournament,
          playerCountBits,
          nextScoreGroupPlayerCountBits,
          scoreDifferenceShift,
          scoreDifferenceShifts,
          minScoreInBracket,
          maxEdgeWeight);

        // Compute the base edge weights.
        const auto edgeWeightComputer =
          [&playersByIndex,
            nextScoreGroupBegin,
            specialBrackets,
            finalBrackets,
            &tournament,
            playerCountBits,
            nextScoreGroupPlayerCountBits,
            scoreDifferenceShift,
            &scoreDifferenceShifts,
            minScoreInBracket,
            &maxEdgeWeight
          ](
            const tournament::player_index smallerPlayerIndex,
            const tournament::player_index largerPlayerIndex)
          {
            return
              computeEdgeWeight(
                *playersByIndex[smallerPlayerIndex],
                *playersByIndex[largerPlayerIndex],
                specialBrackets,
                finalBrackets,
                smallerPlayerIndex < nextScoreGroupBegin,
                largerPlayerIndex < nextScoreGroupBegin,
                tournament,
                playerCountBits,
                nextScoreGroupPlayerCountBits,
                scoreDifferenceShift,
                scoreDifferenceShifts,
                minScoreInBracket,
                maxEdgeWeight);
          };

        std::vector<std::vector<optimality_matching_computer::edge_weight>>
          result(playersByIndex.size());

        for (
          tournament::player_index opponentIndex = scoreGroupBegin;
          opponentIndex < playersByIndex.size();
          ++opponentIndex)
        {
          for (
            tournament::player_index playerIndex = 0;
            playerIndex < opponentIndex;
            ++playerIndex)
          {
            result[opponentIndex].emplace_back(
              edgeWeightComputer(playerIndex, opponentIndex));
          }
        }

        return result;
      }
    }

    /**
     * Compute the matching, and return the list of Pairings in arbitrary order.
     * If no matching is possible, throw a NoValidPairingException.
     * This runs in theoretic time O(n^3 * s * d * log n), where n is the
     * number of players, s is the number of occupied score groups, and d is the
     * number of distinct score differences.
     */
    std::list<Pairing> computeMatching(
      tournament::Tournament &&tournament,
      std::ostream *const ostream)
    {
      // Filter out the absent players, and sort the remainder by score and
      // pairing ID.
      std::list<const tournament::Player *> sortedPlayers;
      for (tournament::Player &player : tournament.players)
      {
        if (player.isValid)
        {
          if (player.matches.size() <= tournament.playedRounds)
          {
            sortedPlayers.push_back(&player);
          }
          for (const tournament::Match &match : player.matches)
          {
            if (match.gameWasPlayed)
            {
              player.forbiddenPairs.insert(match.opponent);
            }
          }
        }
      }
      sortedPlayers.sort(
        [&tournament](const tournament::Player *const player0,
            const tournament::Player *const player1)
        {
          return
            tournament
              ::acceleratedScoreRankCompare(player1, player0, tournament);
        }
      );

      // Initialize a computer used to check whether the round pairing can be
      // completed after pairing zero or more brackets.
      validity_matching_computer validityMatchingComputer(
        validity_matching_computer::size_type{ sortedPlayers.size() }
          + (sortedPlayers.size() & 1u),
        1u);
      if (sortedPlayers.size() > ~validity_matching_computer::size_type{ })
      {
        throw std::length_error("");
      }
      for (
        tournament::player_index playerIndex{ };
        playerIndex < sortedPlayers.size();
        ++playerIndex)
      {
        validityMatchingComputer.addVertex();
      }
      if (sortedPlayers.size() & 1u)
      {
        validityMatchingComputer.addVertex();
      }

      {
        tournament::player_index playerIndex{ };
        for (const tournament::Player *const player : sortedPlayers)
        {
          tournament::player_index opponentIndex{ };
          for (const tournament::Player *const opponent : sortedPlayers)
          {
            if (player != opponent)
            {
              validityMatchingComputer.setEdgeWeight(
                playerIndex,
                opponentIndex,
                compatible(*player, *opponent, tournament));
            }
            ++opponentIndex;
          }
          if (sortedPlayers.size() & 1u)
          {
            validityMatchingComputer.setEdgeWeight(
              playerIndex,
              sortedPlayers.size(),
              eligibleForBye(*player, tournament));
          }
          ++playerIndex;
        }
      }

      // Check whether a pairing is possible initially.
      validityMatchingComputer.computeMatching();
      if (!matchingIsComplete(validityMatchingComputer))
      {
        if (ostream)
        {
          printChecklist(tournament, sortedPlayers, *ostream);
        }
        throw NoValidPairingException(
          "The players could not be simultaneously matched while satisfying "
          "all absolute criteria.");
      }

      /**
       * A vector indicating the match for each player, indexed by player ID.
       * Unmatched players are indicated with null pointers.
       */
      std::vector<const tournament::Player *>
        matchingById(tournament.players.size());

      /**
       * Given the index of a player among those in the current pairing bracket
       * or the next, stores the pointer to the Player.
       */
      std::vector<const tournament::Player *> playersByIndex;
      /**
       * Given the index of a player among those in the current pairing bracket
       * or the next, stores the index of the player in
       * validityMatchingComputer, that is, the index in sortedPlayers.
       */
      std::vector<tournament::player_index> vertexIndices;
      /**
       * An iterator pointing to the beginning of the next score group.
       */
      decltype(sortedPlayers)::const_iterator nextScoreGroupIterator =
        sortedPlayers.begin();
      while (
        nextScoreGroupIterator != sortedPlayers.end()
          && (*nextScoreGroupIterator)->scoreWithAcceleration(tournament)
              >= sortedPlayers.front()->scoreWithAcceleration(tournament))
      {
        playersByIndex.push_back(*nextScoreGroupIterator);
        vertexIndices.push_back(vertexIndices.size());
        ++nextScoreGroupIterator;
      }

      /**
       * true if we are pairing the last pairing bracket or the PPB.
       */
      bool specialBrackets = nextScoreGroupIterator == sortedPlayers.end();

      /**
       * The number of moved down players in the current pairing bracket.
       */
      tournament::player_index scoreGroupBegin{ };

      while (
        playersByIndex.size() > 1u
          || nextScoreGroupIterator != sortedPlayers.end())
      {
        /**
         * The number of players in the current pairing bracket.
         */
        const tournament::player_index nextScoreGroupBegin =
          playersByIndex.size();
        /**
         * Save the iterator to the beginning of the next score group.
         */
        const decltype(sortedPlayers)::const_iterator scoreGroupIterator =
          nextScoreGroupIterator;
        while (
          nextScoreGroupIterator != sortedPlayers.end()
            && (specialBrackets
                  || (*nextScoreGroupIterator)
                        ->scoreWithAcceleration(tournament)
                      >= (*scoreGroupIterator)
                          ->scoreWithAcceleration(tournament)))
        {
          playersByIndex.push_back(*nextScoreGroupIterator);
          vertexIndices.push_back(vertexIndices.back() + 1u);
          ++nextScoreGroupIterator;
        }

        optimality_matching_computer::edge_weight maxEdgeWeight{ 0u };

        // Compute maxEdgeWeight, as well as the base edge weights.
        std::vector<std::vector<optimality_matching_computer::edge_weight>>
            baseEdgeWeights =
          computeBaseEdgeWeights(
            maxEdgeWeight,
            playersByIndex,
            scoreGroupBegin,
            nextScoreGroupBegin,
            specialBrackets,
            nextScoreGroupIterator == sortedPlayers.end(),
            tournament);

        // Initialize the matching computer used to optimize the pairing in the
        // current pairing bracket
        optimality_matching_computer optimalityMatchingComputer(
          playersByIndex.size(),
          maxEdgeWeight);
        if (playersByIndex.size() > ~optimality_matching_computer::size_type{ })
        {
          throw std::length_error("");
        }
        for (
          tournament::player_index playerIndex = 0;
          playerIndex < playersByIndex.size();
          ++playerIndex)
        {
          optimalityMatchingComputer.addVertex();
        }

        {
          tournament::player_index opponentIndex{ };
          for (
            const std::vector<optimality_matching_computer::edge_weight>
                &opponentVector
              : baseEdgeWeights)
          {
            tournament::player_index playerIndex = 0;
            for (
              const optimality_matching_computer::edge_weight &edgeWeight
                : opponentVector)
            {
              optimalityMatchingComputer.setEdgeWeight(
                opponentIndex,
                playerIndex,
                edgeWeight);
              ++playerIndex;
            }
            ++opponentIndex;
          }
        }

        /**
         * The number of bits needed to represent the number of players in the
         * current pairing bracket.
         */
        const unsigned int playerCountBits =
          utility::typesizes::bitsToRepresent<unsigned int>(
            nextScoreGroupBegin - scoreGroupBegin);

        /**
         * A function used to calculate an edge weight modified for pairing
         * homogeneous brackets or remainders with some of the exchange
         * preferences.
         */
        const auto edgeWeightComputer =
          [&baseEdgeWeights, playerCountBits](
            const tournament::player_index smallerPlayerIndex,
            const tournament::player_index largerPlayerIndex,
            const tournament::player_index smallerPlayerRemainderIndex,
            const tournament::player_index remainderPairs)
          {
            optimality_matching_computer::edge_weight result =
              baseEdgeWeights[largerPlayerIndex][smallerPlayerIndex];

            if (result)
            {
              optimality_matching_computer::edge_weight addend =
                result & 0u;

              // Minimize the number of exchanges.
              addend |= smallerPlayerRemainderIndex < remainderPairs;

              // Minimize the difference of the exchanged branch scoring
              // numbers.
              addend <<= playerCountBits;
              addend <<= playerCountBits;
              addend -= smallerPlayerRemainderIndex;

              // Leave room for optimizing based on which players are exchanged.
              addend <<= 1u;

              result += addend;
            }

            return result;
          };

        optimalityMatchingComputer.computeMatching();

        auto stableMatching = optimalityMatchingComputer.getMatching();

        /**
         * Stores whether the player will be matched. The vector is indexed by
         * player index (index within this pairing bracket).
         */
        std::vector<bool> matched(nextScoreGroupBegin);

        // Choose the moved down players to pair in the current pairing bracket.

        /**
         * The score of the moved down players we are currently considering.
         */
        tournament::points movedDownScoreGroup;
        /**
         * The number of moved down players with score movedDownScoreGroup that
         * we have not considered yet.
         */
        tournament::player_index remainingMovedDownScoreGroupPlayers;
        /**
         * The number of moved down players with score movedDownScoreGroup that
         * we will be able to match among those we have not considered yet.
         */
        tournament::player_index remainingMatchedMovedDownScoreGroupPlayers;
        for (
          tournament::player_index playerIndex = 0;
          playerIndex < scoreGroupBegin;
          ++playerIndex)
        {
          if (
            !playerIndex
              || playersByIndex[playerIndex]->scoreWithAcceleration(tournament)
                  < movedDownScoreGroup)
          {
            // Count the number of moved down players with the same score as
            // playerIndex, as well as the number of these that can be matched.
            movedDownScoreGroup =
              playersByIndex[playerIndex]->scoreWithAcceleration(tournament);
            remainingMatchedMovedDownScoreGroupPlayers = 0;
            remainingMovedDownScoreGroupPlayers = 0;
            for (
              tournament::player_index movedDownPlayerIndex = playerIndex;
              playersByIndex[movedDownPlayerIndex]
                  ->scoreWithAcceleration(tournament)
                >= movedDownScoreGroup;
              ++movedDownPlayerIndex)
            {
              ++remainingMovedDownScoreGroupPlayers;
              if (
                stableMatching[movedDownPlayerIndex] >= scoreGroupBegin
                  && stableMatching[movedDownPlayerIndex] < nextScoreGroupBegin)
              {
                ++remainingMatchedMovedDownScoreGroupPlayers;
              }
            }
          }
          if (!remainingMatchedMovedDownScoreGroupPlayers)
          {
            continue;
          }
          if (
            remainingMovedDownScoreGroupPlayers
              <= remainingMatchedMovedDownScoreGroupPlayers)
          {
            matched[playerIndex] = true;
            continue;
          }
          --remainingMovedDownScoreGroupPlayers;
          if (
            stableMatching[playerIndex] < scoreGroupBegin
              || stableMatching[playerIndex] >= nextScoreGroupBegin)
          {
            // Try to match the player.
            for (
              tournament::player_index opponentIndex = scoreGroupBegin;
              opponentIndex < nextScoreGroupBegin;
              ++opponentIndex)
            {
              optimality_matching_computer::edge_weight edgeWeight =
                baseEdgeWeights[opponentIndex][playerIndex];
              if (edgeWeight)
              {
                edgeWeight |= 1u;
                optimalityMatchingComputer.setEdgeWeight(
                  playerIndex,
                  opponentIndex,
                  std::move(edgeWeight));
              }
            }

            optimalityMatchingComputer.computeMatching();

            stableMatching = optimalityMatchingComputer.getMatching();
          }
          if (
            stableMatching[playerIndex] >= scoreGroupBegin
              && stableMatching[playerIndex] < nextScoreGroupBegin)
          {
            // Finalize the fact that this player will be matched.
            matched[playerIndex] = true;
            --remainingMatchedMovedDownScoreGroupPlayers;
            for (
              tournament::player_index opponentIndex = scoreGroupBegin;
              opponentIndex < nextScoreGroupBegin;
              ++opponentIndex)
            {
              optimality_matching_computer::edge_weight edgeWeight =
                baseEdgeWeights[opponentIndex][playerIndex];
              if (edgeWeight)
              {
                edgeWeight |= nextScoreGroupBegin - scoreGroupBegin;
                ++edgeWeight;
                optimalityMatchingComputer.setEdgeWeight(
                  playerIndex,
                  opponentIndex,
                  std::move(edgeWeight));
              }
            }
          }
        }

        // Choose the opponents of the moved down players.
        for (
          tournament::player_index playerIndex = 0;
          playerIndex < scoreGroupBegin;
          ++playerIndex)
        {
          if (!matched[playerIndex])
          {
            continue;
          }
          optimality_matching_computer::edge_weight addend =
            (maxEdgeWeight & 0u) | playersByIndex.size();
          for (
            tournament::player_index opponentIndex = nextScoreGroupBegin - 1u;
            opponentIndex >= scoreGroupBegin;
            --opponentIndex)
          {
            if (matched[opponentIndex])
            {
              continue;
            }
            optimality_matching_computer::edge_weight edgeWeight =
              baseEdgeWeights[opponentIndex][playerIndex];
            if (edgeWeight)
            {
              edgeWeight += addend;
              optimalityMatchingComputer.setEdgeWeight(
                playerIndex,
                opponentIndex,
                std::move(edgeWeight));
              ++addend;
            }
          }

          optimalityMatchingComputer.computeMatching();
          stableMatching = optimalityMatchingComputer.getMatching();

          // Finalize the pairing.
          const tournament::player_index matchIndex =
            stableMatching[playerIndex];
          matched[matchIndex] = true;
          finalizePair(
            playerIndex,
            matchIndex,
            optimalityMatchingComputer,
            maxEdgeWeight);
          finalizePair(
            vertexIndices[playerIndex],
            vertexIndices[matchIndex],
            validityMatchingComputer);
        }

        /**
         * Collects the player indexes of the players in the remainder.
         */
        std::deque<tournament::player_index> remainder;

        /**
         * The number of pairs that can be formed in the remainder.
         */
        tournament::player_index remainderPairs{ };

        /**
         * Initialize remainder and remainderPairs.
         */
        for (
          tournament::player_index playerIndex = scoreGroupBegin;
          playerIndex < nextScoreGroupBegin;
          ++playerIndex)
        {
          if (stableMatching[playerIndex] < scoreGroupBegin)
          {
            continue;
          }
          remainder.push_back(playerIndex);
          if (stableMatching[playerIndex] < playerIndex)
          {
            ++remainderPairs;
          }
        }
        /**
         * An iterator to the first element in remainder that is in the lower
         * group of players.
         */
        decltype(remainder)::const_iterator firstGroupEnd =
          std::next(remainder.begin(), remainderPairs);

        // Update edge weights to minimize exchanged players and the differences
        // of exchanged BSNs.
        for (const tournament::player_index opponentIndex : remainder)
        {
          tournament::player_index playerRemainderIndex{ };
          for (const tournament::player_index playerIndex : remainder)
          {
            if (opponentIndex <= playerIndex)
            {
              break;
            }
            optimalityMatchingComputer.setEdgeWeight(
              playerIndex,
              opponentIndex,
              edgeWeightComputer(
                playerIndex,
                opponentIndex,
                playerRemainderIndex,
                remainderPairs));
            ++playerRemainderIndex;
          }
        }

        optimalityMatchingComputer.computeMatching();
        stableMatching = optimalityMatchingComputer.getMatching();

        /**
         * The number of exchanges that must be made.
         */
        tournament::player_index exchangeCount{ };
        for (const tournament::player_index playerIndex : remainder)
        {
          if (playerIndex >= *firstGroupEnd)
          {
            break;
          }
          exchangeCount +=
            stableMatching[playerIndex] <= playerIndex
              || stableMatching[playerIndex] >= nextScoreGroupBegin;
        }

        // Select lower players from the higher group to be exchanged where
        // possible.

        tournament::player_index exchangesRemaining = exchangeCount;
        tournament::player_index playerRemainderIndex = remainderPairs;
        for (
          decltype(remainder)::const_iterator playerIterator = firstGroupEnd;
          playerIterator != remainder.begin() && exchangesRemaining;
        )
        {
          // Update edge weights to determine whether the current player can
          // be exchanged.
          decltype(remainder)::const_iterator opponentIterator = playerIterator;
          --playerRemainderIndex;
          --playerIterator;
          if (
            stableMatching[*playerIterator] > *playerIterator
              && stableMatching[*playerIterator] < nextScoreGroupBegin)
          {
            while (opponentIterator != remainder.end())
            {
              optimality_matching_computer::edge_weight edgeWeight =
                edgeWeightComputer(
                  *playerIterator,
                  *opponentIterator,
                  playerRemainderIndex,
                  remainderPairs);
              if (edgeWeight)
              {
                edgeWeight -= 1u;
                optimalityMatchingComputer.setEdgeWeight(
                  *playerIterator,
                  *opponentIterator,
                  std::move(edgeWeight));
              }
              ++opponentIterator;
            }

            optimalityMatchingComputer.computeMatching();

            stableMatching = optimalityMatchingComputer.getMatching();
          }

          const bool exchange =
            stableMatching[*playerIterator] <= *playerIterator
              || stableMatching[*playerIterator] >= nextScoreGroupBegin;

          exchangesRemaining -= exchange;

          opponentIterator = std::next(playerIterator, 1);
          while (opponentIterator != remainder.end())
          {
            // Finalize that this player must be exchanged, or restore the
            // original edge weights.
            if (exchange)
            {
              baseEdgeWeights[*opponentIterator][*playerIterator] &= 0u;
            }
            optimalityMatchingComputer.setEdgeWeight(
              *playerIterator,
              *opponentIterator,
              edgeWeightComputer(
                *playerIterator,
                *opponentIterator,
                playerRemainderIndex,
                remainderPairs));
            ++opponentIterator;
          }
        }

        // Select higher players from the lower group to be exchanged where
        // possible.

        exchangesRemaining = exchangeCount;
        tournament::player_index remainderIndex = remainderPairs;
        for (
          decltype(remainder)::const_iterator playerIterator = firstGroupEnd;
          playerIterator != remainder.end() && exchangesRemaining > 1u;
          ++playerIterator)
        {
          const bool alreadyExchanged =
            stableMatching[*playerIterator] > *playerIterator
              && stableMatching[*playerIterator] < nextScoreGroupBegin;
          if (!alreadyExchanged)
          {
            // Update edge weights to determine whether the current player
            // can be exchanged.
            for (
              decltype(remainder)::const_iterator opponentIterator =
                std::next(playerIterator, 1);
              opponentIterator != remainder.end();
              ++opponentIterator)
            {
              optimality_matching_computer::edge_weight edgeWeight =
                edgeWeightComputer(
                  *playerIterator,
                  *opponentIterator,
                  remainderIndex,
                  remainderPairs);
              if (edgeWeight)
              {
                edgeWeight += 1u;
                optimalityMatchingComputer.setEdgeWeight(
                  *playerIterator,
                  *opponentIterator,
                  std::move(edgeWeight));
              }
            }

            optimalityMatchingComputer.computeMatching();

            stableMatching = optimalityMatchingComputer.getMatching();
          }

          const bool exchange =
            stableMatching[*playerIterator] > *playerIterator
              && stableMatching[*playerIterator] < nextScoreGroupBegin;

          if (exchange)
          {
            --exchangesRemaining;

            // Finalize that this player must be exchanged.

            for (
              decltype(remainder)::const_iterator opponentIterator =
                remainder.begin();
              opponentIterator != playerIterator;
              ++opponentIterator)
            {
              baseEdgeWeights[*playerIterator][*opponentIterator] &= 0u;
              optimalityMatchingComputer.setEdgeWeight(
                *playerIterator,
                *opponentIterator,
                baseEdgeWeights[*playerIterator][*opponentIterator]);
            }

            for (
              tournament::player_index opponentIndex = nextScoreGroupBegin;
              opponentIndex < playersByIndex.size();
              ++opponentIndex)
            {
              baseEdgeWeights[opponentIndex][*playerIterator] &= 0u;
              optimalityMatchingComputer.setEdgeWeight(
                *playerIterator,
                opponentIndex,
                baseEdgeWeights[opponentIndex][*playerIterator]);
            }
          }
          if (!alreadyExchanged)
          {
            // Restore the original edge weights.
            for (
              decltype(remainder)::const_iterator opponentIterator =
                std::next(playerIterator, 1);
              opponentIterator != remainder.end();
              ++opponentIterator)
            {
              optimalityMatchingComputer.setEdgeWeight(
                *playerIterator,
                *opponentIterator,
                edgeWeightComputer(
                  *playerIterator,
                  *opponentIterator,
                  remainderIndex,
                  remainderPairs));
            }
          }
          ++remainderIndex;
        }

        // Finalize which players will be exchanged, and reset the bits we used
        // for determining that.
        remainderIndex = 0;
        for (
          decltype(remainder)::const_iterator playerIterator =
            remainder.begin();
          playerIterator != remainder.end();
          ++playerIterator)
        {
          for (
            decltype(remainder)::const_iterator opponentIterator =
              std::next(playerIterator, 1);
            opponentIterator != remainder.end();
            ++opponentIterator)
          {
            if (
              stableMatching[*playerIterator] <= *playerIterator
                || stableMatching[*playerIterator] >= nextScoreGroupBegin
                || (stableMatching[*opponentIterator] > *opponentIterator
                      && stableMatching[*opponentIterator] < nextScoreGroupBegin
                    )
            )
            {
              baseEdgeWeights[*opponentIterator][*playerIterator] &= 0u;
            }
            optimalityMatchingComputer.setEdgeWeight(
              *playerIterator,
              *opponentIterator,
              baseEdgeWeights[*opponentIterator][*playerIterator]);
          }
          ++remainderIndex;
        }

        // Choose the players to be paired with each of the players in the first
        // group.
        remainderIndex = 0;
        for (const tournament::player_index playerIndex : remainder)
        {
          if (
            stableMatching[playerIndex] > playerIndex
              && stableMatching[playerIndex] < nextScoreGroupBegin)
          {
            // Set edge weights to prioritize higher players.
            tournament::player_index addend{ };
            for (
              decltype(remainder)::const_reverse_iterator opponentIterator =
                remainder.rbegin();
              opponentIterator != remainder.rend();
              ++opponentIterator)
            {
              if (
                *opponentIterator <= playerIndex || matched[*opponentIterator])
              {
                continue;
              }
              optimality_matching_computer::edge_weight edgeWeight =
                baseEdgeWeights[*opponentIterator][playerIndex];
              if (edgeWeight)
              {
                edgeWeight += addend;
                optimalityMatchingComputer.setEdgeWeight(
                  playerIndex,
                  *opponentIterator,
                  std::move(edgeWeight));
              }
              ++addend;
            }

            optimalityMatchingComputer.computeMatching();

            stableMatching = optimalityMatchingComputer.getMatching();

            // Finalize the pairing.
            const tournament::player_index matchIndex =
              stableMatching[playerIndex];
            matched[playerIndex] = true;
            matched[matchIndex] = true;
            finalizePair(
              playerIndex,
              matchIndex,
              optimalityMatchingComputer,
              maxEdgeWeight);
            finalizePair(
              vertexIndices[playerIndex],
              vertexIndices[matchIndex],
              validityMatchingComputer);
          }
          ++remainderIndex;
        }

        if (!specialBrackets)
        {
          // Check whether the selected downfloaters allow completion of the
          // round pairing.
          validityMatchingComputer.computeMatching();
          if (!matchingIsComplete(validityMatchingComputer))
          {
            // This bracket is the PPB. Repair it.
            playersByIndex.erase(
              playersByIndex.begin() + nextScoreGroupBegin,
              playersByIndex.end());
            vertexIndices.erase(
              vertexIndices.begin() + nextScoreGroupBegin,
              vertexIndices.end());
            nextScoreGroupIterator = scoreGroupIterator;
            specialBrackets = true;
            continue;
          }
        }

        // Compute the new values for the next pairing bracket.
        specialBrackets = nextScoreGroupIterator == sortedPlayers.end();

        std::vector<const tournament::Player *> newPlayersByIndex;
        std::vector<tournament::player_index> newVertexIndices;
        scoreGroupBegin = 0;
        for (
          tournament::player_index playerIndex = 0;
          playerIndex < playersByIndex.size();
          ++playerIndex)
        {
          if (playerIndex < nextScoreGroupBegin && matched[playerIndex])
          {
            // Save the pair in matchingById.
            matchingById[playersByIndex[playerIndex]->id] =
              playersByIndex[stableMatching[playerIndex]];
            matchingById[playersByIndex[stableMatching[playerIndex]]->id] =
              playersByIndex[playerIndex];
          }
          else
          {
            // Add the player to the next bracket.
            newPlayersByIndex.push_back(playersByIndex[playerIndex]);
            newVertexIndices.push_back(vertexIndices[playerIndex]);
            if (playerIndex < nextScoreGroupBegin)
            {
              ++scoreGroupBegin;
            }
          }
        }

        playersByIndex = std::move(newPlayersByIndex);
        vertexIndices = std::move(newVertexIndices);
      }

      // Generate the list of Pairings.
      std::list<Pairing> result;
      for (const tournament::Player *const player : sortedPlayers)
      {
        const tournament::Player *const match = matchingById[player->id];
        if (match)
        {
          assert(player->isValid);
          assert(player->matches.size() <= tournament.playedRounds);
          assert(match->isValid);
          assert(match->matches.size() <= tournament.playedRounds);
          if (player->id < match->id)
          {
            result.emplace_back(
              player->id,
              match->id,
              choosePlayerColor(
                tournament.players[player->id],
                *match,
                tournament));
          }
        }
        else
        {
          result.emplace_back(player->id, player->id);
        }
      }

      // Print the checklist.
      if (ostream)
      {
        printChecklist(tournament, sortedPlayers, *ostream, &matchingById);
      }

      return result;
    }
  }
}
#endif
